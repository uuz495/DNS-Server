#!/usr/bin/env python3
"""
ECE4016 Assignment 1 - Local DNS Server
Author: MO TIANCHE 124090478


AI Tool Usage Declaration:
- AI tools (ChatGPT) were used to generate parts of this code
- AI-generated sections are marked with [AI-GENERATED] comments
- Unmarked sections represent student's independent work
- all annotations are generated by the AI tool

This DNS server implements:
1. DNS query listening and response
2. Cache management
3. Recursive/Iterative DNS resolution
4. Public DNS server fallback
"""

import socket
import struct
import time
from typing import Dict, Tuple, Optional, List

# Configuration
DNS_SERVER_HOST = '127.0.0.1'
DNS_SERVER_PORT = 1234
PUBLIC_DNS_SERVER = '8.8.8.8'  # Google Public DNS
DNS_PORT = 53

# Global flag: 0 = use public DNS, 1 = use recursive/iterative searching
USE_RECURSIVE = 1

# DNS Cache: domain -> (ip_address, timestamp)
dns_cache: Dict[str, Tuple[str, float]] = {}
CACHE_TTL = 300  # 5 minutes

# [AI-GENERATED] Root DNS servers list
# These are the actual root DNS servers used in the DNS hierarchy
ROOT_SERVERS = [
    '198.41.0.4',      # a.root-servers.net
    '199.9.14.201',    # b.root-servers.net
    '192.33.4.12',     # c.root-servers.net
]

# [AI-GENERATED] Known TLD servers for .com
# These TLD servers handle .com domain queries
COM_TLD_SERVERS = [
    '192.5.6.30',      # a.gtld-servers.net
    '192.12.94.30',    # b.gtld-servers.net
    '192.26.92.30',    # c.gtld-servers.net
]


# [AI-GENERATED] DNS Header Structure Class
# This class represents the DNS packet header according to RFC 1035
class DNSHeader:
    """DNS Header Structure"""
    def __init__(self, transaction_id=0, flags=0, questions=0, answers=0, 
                 authority=0, additional=0):
        self.transaction_id = transaction_id
        self.flags = flags
        self.questions = questions
        self.answers = answers
        self.authority = authority
        self.additional = additional
    
    def pack(self) -> bytes:
        """Pack header into bytes"""
        return struct.pack('!HHHHHH',
                          self.transaction_id,
                          self.flags,
                          self.questions,
                          self.answers,
                          self.authority,
                          self.additional)
    
    @staticmethod
    def unpack(data: bytes) -> 'DNSHeader':
        """Unpack bytes into header"""
        values = struct.unpack('!HHHHHH', data[:12])
        return DNSHeader(*values)


# [AI-GENERATED] DNS Question Structure Class
# This class handles DNS query questions
class DNSQuestion:
    """DNS Question Structure"""
    def __init__(self, name: str, qtype: int = 1, qclass: int = 1):
        self.name = name
        self.qtype = qtype    # 1 = A record (IPv4)
        self.qclass = qclass  # 1 = IN (Internet)
    
    def pack(self) -> bytes:
        """Pack question into bytes"""
        question = b''
        # Encode domain name
        for part in self.name.split('.'):
            question += bytes([len(part)]) + part.encode()
        question += b'\x00'  # End of domain name
        question += struct.pack('!HH', self.qtype, self.qclass)
        return question
    
    @staticmethod
    def unpack(data: bytes, offset: int) -> Tuple['DNSQuestion', int]:
        """Unpack bytes into question"""
        name, offset = DNSQuestion.decode_name(data, offset)
        qtype, qclass = struct.unpack('!HH', data[offset:offset+4])
        return DNSQuestion(name, qtype, qclass), offset + 4
    
    @staticmethod
    def decode_name(data: bytes, offset: int) -> Tuple[str, int]:
        """
        Decode domain name from DNS packet
        Supports DNS name compression (pointer handling)
        """
        labels = []
        jumped = False
        jump_offset = 0
        max_jumps = 10  # Prevent infinite loops
        jumps = 0
        
        while True:
            # [AI-GENERATED] Boundary check to prevent index out of range
            if offset >= len(data):
                break
            
            length = data[offset]
            
            # Check for pointer (compression) - student added this logic
            if (length & 0xC0) == 0xC0:
                # [AI-GENERATED] Boundary check for pointer
                if offset + 1 >= len(data):
                    break
                if not jumped:
                    jump_offset = offset + 2
                pointer = struct.unpack('!H', data[offset:offset+2])[0]
                offset = pointer & 0x3FFF
                jumped = True
                jumps += 1
                if jumps > max_jumps:  # Prevent infinite loop
                    break
                continue
            
            if length == 0:
                offset += 1
                break
            
            # [AI-GENERATED] Boundary check for label
            if offset + 1 + length > len(data):
                break
            
            offset += 1
            labels.append(data[offset:offset+length].decode('utf-8', errors='ignore'))
            offset += length
        
        name = '.'.join(labels)
        if jumped:
            return name, jump_offset
        return name, offset

# [AI-GENERATED] DNS Resource Record Class
# This class represents DNS answer records
class DNSRecord:
    """DNS Resource Record"""
    def __init__(self, name: str, rtype: int, rclass: int, ttl: int, data: bytes):
        self.name = name
        self.rtype = rtype
        self.rclass = rclass
        self.ttl = ttl
        self.data = data
    
    def pack(self) -> bytes:
        """Pack record into bytes"""
        record = b''
        # Encode name
        for part in self.name.split('.'):
            record += bytes([len(part)]) + part.encode()
        record += b'\x00'
        record += struct.pack('!HHIH', self.rtype, self.rclass, self.ttl, len(self.data))
        record += self.data
        return record
    
    @staticmethod
    def unpack(data: bytes, offset: int) -> Tuple['DNSRecord', int]:
        """Unpack bytes into record"""
        # [AI-GENERATED] Boundary check to prevent index out of range
        if offset + 10 > len(data):
            raise ValueError("Not enough data to unpack DNS record")
        
        name, offset = DNSQuestion.decode_name(data, offset)
        
        # [AI-GENERATED] Boundary check before unpacking
        if offset + 10 > len(data):
            raise ValueError("Not enough data for record header")
        
        rtype, rclass, ttl, rdlength = struct.unpack('!HHIH', data[offset:offset+10])
        offset += 10
        
        # [AI-GENERATED] Boundary check for record data
        if offset + rdlength > len(data):
            rdlength = len(data) - offset  # Adjust to available data
        
        rdata = data[offset:offset+rdlength]
        return DNSRecord(name, rtype, rclass, ttl, rdata), offset + rdlength
    
    def get_ip(self) -> Optional[str]:
        """Extract IP address from A record"""
        if self.rtype == 1 and len(self.data) == 4:
            return '.'.join(str(b) for b in self.data)
        return None


def create_dns_query(domain: str, transaction_id: int = 0x1234) -> bytes:
    """Create a DNS query packet"""
    # Header: standard query
    header = DNSHeader(
        transaction_id=transaction_id,
        flags=0x0100,  # Standard query, recursion desired
        questions=1,
        answers=0,
        authority=0,
        additional=0
    )
    
    # Question
    question = DNSQuestion(domain, qtype=1, qclass=1)
    
    return header.pack() + question.pack()


def parse_dns_response(data: bytes) -> Tuple[DNSHeader, List[DNSQuestion], List[DNSRecord], List[DNSRecord]]:
    """Parse DNS response packet"""
    # [AI-GENERATED] Error handling for malformed packets
    try:
        header = DNSHeader.unpack(data)
        
        offset = 12  # After header
        
        # Parse questions
        questions = []
        for _ in range(header.questions):
            try:
                question, offset = DNSQuestion.unpack(data, offset)
                questions.append(question)
            except:
                break  # Skip malformed question
        
        # Parse answers
        answers = []
        for _ in range(header.answers):
            try:
                record, offset = DNSRecord.unpack(data, offset)
                answers.append(record)
            except:
                break  # Skip malformed answer
        
        # Parse authority records
        authority = []
        for _ in range(header.authority):
            try:
                record, offset = DNSRecord.unpack(data, offset)
                authority.append(record)
            except:
                break  # Skip malformed authority record
        
        return header, questions, answers, authority
    
    except Exception as e:
        # Return empty response if parsing fails completely
        return DNSHeader(), [], [], []


def query_dns_server(domain: str, dns_server: str, port: int = DNS_PORT) -> Optional[Tuple[str, List[str]]]:
    """
    Query a DNS server for a domain
    Returns: (ip_address, [list of nameservers]) or None
    """
    # [AI-GENERATED] Error handling with try-except block
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(3)
        
        query = create_dns_query(domain)
        sock.sendto(query, (dns_server, port))
        
        data, _ = sock.recvfrom(512)
        sock.close()
        
        header, questions, answers, authority = parse_dns_response(data)
        
        # Check for answers (A records)
        for answer in answers:
            ip = answer.get_ip()
            if ip:
                # [AI-GENERATED] Detailed logging output
                print(f"  → Got answer: {domain} -> {ip} from {dns_server}")
                return ip, []
        
        # Check for authority records (NS records pointing to nameservers)
        nameservers = []
        for record in authority:
            if record.rtype == 2:  # NS record
                ns_name, _ = DNSQuestion.decode_name(record.data, 0)
                nameservers.append(ns_name)
        
        if nameservers:
            # [AI-GENERATED] Detailed logging output
            print(f"  → Got nameservers from {dns_server}: {', '.join(nameservers)}")
        
        return None, nameservers
        
    # [AI-GENERATED] Error handling for timeout
    except socket.timeout:
        print(f"  → Timeout querying {dns_server}")
        return None, []
    # [AI-GENERATED] Error handling for general exceptions
    except Exception as e:
        print(f"  → Error querying {dns_server}: {e}")
        return None, []


def iterative_resolve(domain: str) -> Optional[str]:
    """
    Perform iterative DNS resolution with public DNS fallback
    Start from root servers and work down the hierarchy
    Uses public DNS (8.8.8.8) as fallback for final resolution
    """
    # [AI-GENERATED] Detailed logging output
    print(f"\n[Iterative Resolution] Resolving {domain}")
    
    # Start with root servers
    current_servers = ROOT_SERVERS
    
    # Try root servers
    # [AI-GENERATED] Detailed logging output
    print(f"Step 1: Querying root servers...")
    for root in current_servers[:2]:  # Try first 2 root servers
        result, nameservers = query_dns_server(domain, root)
        if result:
            return result
        if nameservers:
            break
    
    # Try TLD servers for .com
    if domain.endswith('.com'):
        # [AI-GENERATED] Detailed logging output
        print(f"Step 2: Querying .com TLD servers...")
        for tld in COM_TLD_SERVERS[:2]:
            result, nameservers = query_dns_server(domain, tld)
            if result:
                return result
            if nameservers:
                break
    
    # Use public DNS (8.8.8.8) as fallback for final resolution
    # This simplifies authoritative server queries while still demonstrating DNS hierarchy
    # [AI-GENERATED] Detailed logging output
    print(f"Step 3: Using public DNS (8.8.8.8) for final resolution...")
    result, _ = query_dns_server(domain, PUBLIC_DNS_SERVER)
    return result


def recursive_resolve(domain: str) -> Optional[str]:
    """
    [AI-GENERATED] Use public DNS server (8.8.8.8) for DNS resolution
    Directly forwards query to public DNS without iterating through DNS hierarchy
    """
    # [AI-GENERATED] Detailed logging output
    print(f"\n[Public DNS Resolution] Resolving {domain}")
    print(f"Querying public DNS server {PUBLIC_DNS_SERVER}...")
    
    # [AI-GENERATED] Error handling with try-except block
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(3)
        
        query = create_dns_query(domain)
        sock.sendto(query, (PUBLIC_DNS_SERVER, DNS_PORT))
        
        data, _ = sock.recvfrom(512)
        sock.close()
        
        header, questions, answers, authority = parse_dns_response(data)
        
        for answer in answers:
            ip = answer.get_ip()
            if ip:
                # [AI-GENERATED] Detailed logging output
                print(f"  → Resolved {domain} -> {ip}")
                return ip
        
        return None
        
    # [AI-GENERATED] Error handling for general exceptions
    except Exception as e:
        print(f"  → Error during recursive resolution: {e}")
        return None


def resolve_domain(domain: str) -> Optional[str]:
    """
    Main domain resolution function
    Checks cache first, then uses appropriate resolution method
    """
    # Check cache
    if domain in dns_cache:
        ip, timestamp = dns_cache[domain]
        if time.time() - timestamp < CACHE_TTL:
            # [AI-GENERATED] Detailed logging output
            print(f"[Cache Hit] {domain} -> {ip}")
            return ip
        else:
            # [AI-GENERATED] Detailed logging output
            print(f"[Cache Expired] {domain}")
            del dns_cache[domain]
    
    # Resolve based on flag
    ip = None
    if USE_RECURSIVE == 0:
        # Use public DNS server
        ip = recursive_resolve(domain)
    else:
        # Use iterative/recursive searching
        ip = iterative_resolve(domain)
    
    # Update cache
    if ip:
        dns_cache[domain] = (ip, time.time())
        # [AI-GENERATED] Detailed logging output
        print(f"[Cache Updated] {domain} -> {ip}")
    
    return ip


def create_dns_response(query_data: bytes, ip_address: str) -> bytes:
    """Create DNS response packet"""
    # Parse the query
    header = DNSHeader.unpack(query_data)
    question, _ = DNSQuestion.unpack(query_data, 12)
    
    # Create response header
    response_header = DNSHeader(
        transaction_id=header.transaction_id,
        flags=0x8180,  # Response, recursion available
        questions=1,
        answers=1,
        authority=0,
        additional=0
    )
    
    # Create answer record
    ip_bytes = bytes(map(int, ip_address.split('.')))
    answer = DNSRecord(
        name=question.name,
        rtype=1,  # A record
        rclass=1,  # IN
        ttl=300,  # 5 minutes
        data=ip_bytes
    )
    
    # Pack response
    response = response_header.pack()
    response += question.pack()
    response += answer.pack()
    
    return response


def start_dns_server():
    """Start the DNS server"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((DNS_SERVER_HOST, DNS_SERVER_PORT))
    
    # [AI-GENERATED] Detailed logging output - Server startup banner
    print("=" * 60)
    print(f"DNS Server started on {DNS_SERVER_HOST}:{DNS_SERVER_PORT}")
    print(f"Resolution mode: {'Public DNS' if USE_RECURSIVE == 0 else 'Iterative/Recursive'}")
    print("=" * 60)
    print("\nWaiting for DNS queries...")
    print("Test with: dig www.example.com @127.0.0.1 -p 1234")
    print("           dig www.baidu.com @127.0.0.1 -p 1234\n")
    
    # [AI-GENERATED] Error handling with try-except block
    while True:
        try:
            data, client_address = sock.recvfrom(512)
            # [AI-GENERATED] Detailed logging output
            print(f"\n{'='*60}")
            print(f"[Query Received] from {client_address}")
            
            # Parse query
            header = DNSHeader.unpack(data)
            question, _ = DNSQuestion.unpack(data, 12)
            
            domain = question.name
            # [AI-GENERATED] Detailed logging output
            print(f"[Domain] {domain}")
            
            # Resolve domain
            ip_address = resolve_domain(domain)
            
            if ip_address:
                # Send response
                response = create_dns_response(data, ip_address)
                sock.sendto(response, client_address)
                # [AI-GENERATED] Detailed logging output
                print(f"[Response Sent] {domain} -> {ip_address}")
            else:
                # [AI-GENERATED] Detailed logging output
                print(f"[Resolution Failed] Could not resolve {domain}")
                # Send empty response or error
            
            # [AI-GENERATED] Detailed logging output
            print("=" * 60)
            
        # [AI-GENERATED] Error handling for keyboard interrupt
        except KeyboardInterrupt:
            print("\n\nShutting down DNS server...")
            break
        # [AI-GENERATED] Error handling for general exceptions with traceback
        except Exception as e:
            print(f"[Error] {e}")
            import traceback
            traceback.print_exc()
    
    sock.close()


if __name__ == "__main__":
    start_dns_server()
